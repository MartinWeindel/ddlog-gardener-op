import json
import document

typedef Kind = KindConfig
               | KindComponent{typeName: string}

typedef SpecStatus = SpecStatus {
    valid: bool,
    errors: Vec<string>
}

output relation Spec(kind: Kind, name: string, valid: bool)


input relation Config(name: string, yaml: string)

output relation InternalConfig(name: string, doc: Document, status: SpecStatus)


InternalConfig(name, doc, status) :-
    Config(name, yaml),
    (var doc, var status) = match (doc_from_yaml_string(yaml)) {
        Ok{doc} -> (doc, makeSpecStatusValid()),
        Err{e} -> (doc_unit(), makeSpecStatusInvalid(e))
    }.

Spec(KindConfig, name, status.valid) :- InternalConfig(name, _, status).


typedef Import = Import {
    name: string,
    source: Source
}

typedef Source = SourceConfig { name: string, select: string }
                 | SourceComponentByName { compName: string, select: string }
                 | SourceComponentByType { compType: string, optCompName: Option<string>, select: string }

typedef Export = Export {
    name: string
}


input relation Component(name: string, typeName: string, spec: string)

output relation InternalComponent(name: string, kind: Kind, 
    imports: Map<string,Import>, exports: Map<string,Export>, status: SpecStatus)

InternalComponent(name, KindComponent{typeName}, imports, exports, status) :- 
    Component(name, typeName, spec),
    (var imports, var exports, var status) = parseComponentSpec(spec).

Spec(kind, name, status.valid) :- InternalComponent(name, kind, _, _, status).

function makeSpecStatusValid() : SpecStatus =
{
    var noErrs : Vec<string> = vec_empty();
    SpecStatus{true,noErrs}
}

function makeSpecStatusInvalid(e: string) : SpecStatus =
{
    var errs : Vec<string> = vec_empty();
    vec_push(errs, e);
    SpecStatus{false,errs}
}

function parseComponentSpec(yaml: string) : (Map<string,Import>, Map<string,Export>, SpecStatus) = 
{
    var imports: Map<string,Import> = map_empty();
    var exports: Map<string,Export> = map_empty();
    var errs : Vec<string> = vec_empty();
    var doc = doc_unit();

    match (doc_from_yaml_string(yaml)) {
        Ok{d} -> doc = d,
        Err{e} ->
          vec_push(errs, e);
          return (imports, exports, SpecStatus{false,errs})
    };

    match (doc_select(doc, ".imports")) {
        Ok{d} ->
          match (doc_as_map(d)) {
              Some{map} ->
                (var imps, var importsErrs) = parseComponentImports(map);
                imports = imps;
                vec_append(errs, importsErrs),
              None ->
                if (not doc_is_unit(d)) {
                    vec_push(errs, "Imports must be a map");
                    return (imports, exports, SpecStatus{false,errs})
                } 
          },
        Err{e} ->
          return (imports, exports, SpecStatus{false,errs})
    };

    // TODO exports
    (imports, exports, SpecStatus{vec_is_empty(errs), errs})
}

function parseComponentImports(map: Map<Document,Document>) : (Map<string,Import>, Vec<string>) =
{
    var imports: Map<string,Import> = map_empty();
    var errs : Vec<string> = vec_empty();

    for (entry in map) {
        (var k, var v) = entry;
        match (doc_as_string(k)) {
            Some{key} ->
                match (doc_select(v, ".sourceType")) {
                    Ok{st} ->
                        match (doc_as_string(st)) {
                            Some{"config"} ->
                                match (parseSourceTypeConfig(key, v)) {
                                    Ok{imp} -> map_insert(imports, key, imp),
                                    Err{e} -> vec_push(errs, e)
                                },
                            Some{"component"} ->
                                match (parseSourceTypeComponent(key, v)) {
                                    Ok{imp} -> map_insert(imports, key, imp),
                                    Err{e} -> vec_push(errs, e)
                                },
                            Some{x} ->
                                vec_push(errs, "imports: invalid sourceType ${x} for key ${key}"),
                            None ->
                                vec_push(errs, "imports: invalid sourceType value for key ${key}")
                        },
                    Err{e} ->
                        vec_push(errs, "imports: select sourceType failed with ${e}")
                },
            None ->
                vec_push(errs, "imports: invalid key:${k}")
        }
    };
    (imports, errs)
}

function parseSourceTypeConfig(key: string, value: Document) : Result<Import, string> = 
{
    var name = "";
    var select = "";
    match (extractStringField(value, "name")) {
        Ok{s} -> name = s,
        Err{e} -> return Err{"imports: key ${key}: ${e}"}
    };
    match (extractStringField(value, "select")) {
        Ok{s} -> select = s,
        Err{e} -> return Err{"imports: key ${key}: ${e}"}
    };
    Ok{Import{key, SourceConfig{name, select}}}
}

function parseSourceTypeComponent(key: string, value: Document) : Result<Import, string> = 
{
    var name : Option<string> = None;
    var typeName : Option<string> = None;
    var select = "";
    match (extractOptionalStringField(value, "name")) {
        Ok{s} -> name = s,
        Err{e} -> return Err{"imports: key ${key}: ${e}"}
    };
    match (extractOptionalStringField(value, "type")) {
        Ok{s} -> typeName = s,
        Err{e} -> return Err{"imports: key ${key}: ${e}"}
    };
    match (extractStringField(value, "select")) {
        Ok{s} -> select = s,
        Err{e} -> return Err{"imports: key ${key}: ${e}"}
    };
    match (typeName) {
        Some{s} ->
            Ok{Import{key, SourceComponentByType{s, name, select}}},
        None ->
            match (name) {
                Some{s} ->
                    Ok{Import{key, SourceComponentByName{s, select}}},
                None ->
                    Err{"imports: key ${key}: either name or type must be set"}
            }
    }
}

function extractStringField(value: Document, key: string) : Result<string, string> = 
{
     match (doc_select(value, ".${key}")) {
        Ok{d} ->
            match (doc_as_string(d)) {
                Some{s} ->
                    Ok{s},
                None ->
                    Err{"${key} value must be a string"}
            },
        Err{e} ->
            Err{"${key} field not found"}
    }
}

function extractOptionalStringField(value: Document, key: string) : Result<Option<string>, string> = 
{
     match (doc_select(value, ".${key}")) {
        Ok{d} ->
            match (doc_as_string(d)) {
                Some{s} ->
                    Ok{Some{s}},
                None ->
                    if (not doc_is_unit(d)) {
                        return Err{"optional ${key} value must be a string"}
                    };
                    Ok{None}
            },
        Err{e} ->
            Err{"${key} field not found"}
    }
}